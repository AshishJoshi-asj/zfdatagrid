#summary How CRUD operations works

= How it works? =

By default the form is built based on table definition.

All data validation is auto added and forms fields are built based also on fields definition.

!Bvb_Grid_Form is just a proxy for Zend_Form or any other class that extends Zend_Form.

You can define you form like this:

{{{
$form = new Bvb_Grid_Form($class='Zend_Form', $options  =array()); //If you use your custom form class, change Zend_Form for your class. 
//Remember that it needs to be an instance of Zend_From. The second argument is the options that will be passed to the class constructor().
}}}


You can define which operations are availbale for users:
{{{
$form->setAdd(true|false);
$form->setEdit(true|false);
$form->setDelete(true|false);
}}}


You can optional add a _add_ button to the top of form by doing this:
{{{
$form->setAddButton(true|false);
}}}


One interesting  thing is that you may use Zend_Form just to validating your data and then do something else with it then saving it to a database.
You can do that by defining this:

{{{
$form->setIsPerformCrudAllowed(false);//Won't insert any data to the source when performing any operation
$form->setIsPerformCrudAllowedForAddition(true|false); //Won't insert any data when adding new data
$form->setIsPerformCrudAllowedForEdition(true|false); //Won't update any data when editing
$form->setIsPerformCrudAllowedForDeletion(false); //Won't delete any data when deleting a record
}}}

Data recording is inside a try{}catch{} block, so you can throw an exception within your callbacks (see below) to make the validation fail.

What if you don't want a specific field?

You can include or exclude fields from the form by setting this:
{{{
$form->setAllowedFields(array('times','nexst'));//Only this fields will appear in the form
$form->setDisallowedFields(array('time','next'));//This fieds won't appear in the form
$form->setFieldsBasedOnQuery(true|false); //Only the fields from the query will be in the form
}}}


And then we need to add the form to our grid
{{{
$grid->setForm($form);
}}}


After adding the form you can get it by doing:
{{{
$grid->getForm(); 
}}}

And do whatever you want with it.
{{{
$grid->getForm->getElement('my_field')->setValue('value');
}}}

=Default Decorators=
To speed things up, default decorators are used and use the table>tr>td layout.

{{{
groupDecorator = array('FormElements', array('HtmlTag', array('tag' => 'td', 'colspan' => '2', 'class' => 'buttons')), array(array('row' => 'HtmlTag'), array('tag' => 'tr')));

elementDecorator = array('ViewHelper', 'Description', 'Errors', array(array('data' => 'HtmlTag'), array('tag' => 'td', 'class' => 'element')), array(array('label' => 'Label'), array('tag' => 'td')), array(array('row' => 'HtmlTag'), array('tag' => 'tr')));

buttonHiddenDecorator = array('ViewHelper');

formDecorator = array('FormElements', array('HtmlTag', array('tag' => 'table', 'style' => 'width:99%', 'class' => 'borders')), 'Form');

}}}

==Change Decorators==

If you want to change your decorators use the following methods. 
_*NOTE:*_ You must change the decorators befor adding the form to the grid,
{{{
$form->(set|get)groupDecorator();
$form->(set|get)elementDecorator();
$form->(set|get)buttonHiddenDecorator();
$form->(set|get)formDecorator();
}}}


=Callbacks=

Callbacks will be performed before and after any action in the source.

The callback function will receive two arguments, first the data that will be inserted and second the source instance
{{{
$form->setCallbackBeforeDelete ($callback)
$form->setCallbackBeforeUpdate ($callback)
$form->setCallbackBeforeInsert ($callback)
$form->setCallbackAfterDelete ($callback)
$form->setCallbackAfterUpdate ($callback)
$form->setCallbackAfterInsert ($callback)
}}}